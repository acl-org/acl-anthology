<?xml version='1.0' encoding='UTF-8'?>
<collection id="1995.iwpt">
  <volume id="1" ingest-date="2020-05-11">
    <meta>
      <booktitle>Proceedings of the Fourth International Workshop on Parsing Technologies</booktitle>
      <publisher>Association for Computational Linguistics</publisher>
      <address>Prague and Karlovy Vary, Czech Republic</address>
      <month>September 20-24</month>
      <year>1995</year>
      <editor><first>Eva</first><last>Hajicova</last></editor>
      <editor><first>Bernard</first><last>Lang</last></editor>
      <editor><first>Robert</first><last>Berwick</last></editor>
      <editor><first>Harry</first><last>Bunt</last></editor>
      <editor><first>Bob</first><last>Carpenter</last></editor>
      <editor><first>Ken</first><last>Church</last></editor>
      <editor><first>Aravind</first><last>Joshi</last></editor>
      <editor><first>Ronald</first><last>Kaplan</last></editor>
      <editor><first>Martin</first><last>Kay</last></editor>
      <editor><first>Makoto</first><last>Nagao</last></editor>
      <editor><first>Anton</first><last>Nijholt</last></editor>
      <editor><first>Mark</first><last>Steedman</last></editor>
      <editor><first>Henry</first><last>Thompson</last></editor>
      <editor><first>Masaru</first><last>Tomita</last></editor>
      <editor><first>K.</first><last>Vijay-Shanker</last></editor>
      <editor><first>Yorick</first><last>Wilks</last></editor>
      <editor><first>Kent</first><last>Wittenburg</last></editor>
      <url hash="00f89111">1995.iwpt-1</url>
      <venue>iwpt</venue>
      <venue>ws</venue>
    </meta>
    <paper id="1">
      <title>Proceedings of the Fourth International Workshop on Parsing Technologies</title>
      <pages>i-ix</pages>
      <url hash="98aceb46">1995.iwpt-1.1</url>
      <abstract/>
      <bibkey>nn-1995-proceedings</bibkey>
    </paper>
    <paper id="2">
      <title>Acyclic Context-sensitive Grammars</title>
      <author><first>Erik</first><last>Aarts</last></author>
      <pages>1-9</pages>
      <url hash="faf55605">1995.iwpt-1.2</url>
      <abstract>A grammar formalism is introduced that generates parse trees with crossing branches. The uniform recognition problem is NP-complete, but for any fixed grammar the recognition problem is polynomial.</abstract>
      <bibkey>aarts-1995-acyclic</bibkey>
    </paper>
    <paper id="3">
      <title>Parsing in Dialogue Systems Using Typed Feature Structures</title>
      <author><first>Rieks</first><last>op den Akker</last></author>
      <author><first>Hugo</first><last>ter Doest</last></author>
      <author><first>Mark</first><last>Moll</last></author>
      <author><first>Anton</first><last>Nijholt</last></author>
      <pages>10-11</pages>
      <url hash="7e0f1711">1995.iwpt-1.3</url>
      <abstract>The analysis of natural language in the context of keyboard-driven dialogue systems is the central issue addressed in this paper. A module that corrects typing errors, performs domain-specific morphological analysis is developed. A parser for typed unification grammars is designed and implemented in C++; for description of the lexicon and the grammer a specialised specification language is developed. It is argued that typed unification grammars and especially the newly developed specification language are convenient formalisms for describing natural language use in dialogue systems. Research on these issues is carried out in the context of the SCHISMA project, a research project in linguistic engineering; participants in SCHISMA are KPN Research and the University of Twente.</abstract>
      <bibkey>op-den-akker-etal-1995-parsing</bibkey>
    </paper>
    <paper id="4">
      <title>Parallel Parsing: Different Distribution Schemata for Charts</title>
      <author><first>Jan W.</first><last>Amtrup</last></author>
      <pages>12-13</pages>
      <url hash="cb0c9708">1995.iwpt-1.4</url>
      <abstract/>
      <bibkey>amtrup-1995-parallel</bibkey>
    </paper>
    <paper id="5">
      <title>A Fuzzy Approach to Erroneous Inputs in Context-Free Language Recognition</title>
      <author><first>Peter R.J.</first><last>Asveld</last></author>
      <pages>14-25</pages>
      <url hash="b5f21bca">1995.iwpt-1.5</url>
      <abstract>Using fuzzy context-free grammars one can easily describe a finite number of ways to derive incorrect strings together with their degree of correctness. However, in general there is an infinite number of ways to perform a certain task wrongly. In this paper we introduce a generalization of fuzzy context-free grammars, the so-called fuzzy context-free <tex-math>K</tex-math>-grammars, to model the situation of malting a finite choice out of an infinity of possible grammatical errors during each context-free derivation step. Under minor assumptions on the parameter <tex-math>K</tex-math> this model happens to be a very general framework to describe correctly as well as erroneously derived sentences by a single generating mechanism. Our first result characterizes the generating capacity of these fuzzy context-free <tex-math>K</tex-math>-grammars. As consequences we obtain: (i) bounds on modeling grammatical errors within the framework of fuzzy context-free grammars, and (ii) the fact that the family of languages generated by fuzzy context-free <tex-math>K</tex-math>-grammars shares closure properties very similar to those of the family of ordinary context-free languages. The second part of the paper is devoted to a few algorithms to recognize fuzzy context-free languages: viz. a variant of a functional version of Cocke-Younger-Kasami’s algorithm and some recursive descent algorithms. These algorithms tum out to be robust in some very elementary sense and they can easily be extended to corresponding parsing algorithms.</abstract>
      <bibkey>asveld-1995-fuzzy</bibkey>
    </paper>
    <paper id="6">
      <title>Parsing Non-Immediate Dominance Relations</title>
      <author><first>Tilman</first><last>Becker</last></author>
      <author><first>Owen</first><last>Rambow</last></author>
      <pages>26-33</pages>
      <url hash="0de5e2b6">1995.iwpt-1.6</url>
      <abstract>We present a new technique for parsing grammar formalisms that express non-immediate dominance relations by ‘dominance-links’. Dominance links have been introduced in various formalisms such as extensions to CFG and TAG in order to capture long-distance dependencies in free-word order languages (Becker et al., 1991; Rambow, 1994). We show how the addition of ‘link counters’ to standard parsing algorithms such as CKY- and Earley-based methods for TAG results in a polynomial time complexity algorithm for parsing lexicalized V-TAG, a multi-component version of TAGs defined in (Rambow, 1994). A variant of this method has previously been applied to context-free grammar based formalisms such as UVG-DL.</abstract>
      <bibkey>becker-rambow-1995-parsing</bibkey>
    </paper>
    <paper id="7">
      <title>Yet Another <tex-math>0(n^6)</tex-math> Recognition Algorithm for Mildly Context-Sensitive Languages</title>
      <author><first>Pierre</first><last>Boullier</last></author>
      <pages>34-47</pages>
      <url hash="c81f7052">1995.iwpt-1.7</url>
      <abstract>Vijay-Shanker and Weir have shown in [17] that Tree Adjoining Grammars and Combinatory Categorial Grammars can be transformed into equivalent Linear Indexed Grammars (LIGs) which can be recognized in <tex-math>0(n^6)</tex-math> time using a Cocke-Kasami-Younger style algorithm. This paper exhibits another recognition algorithm for LIGs, with the same upper-bound complexity, but whose average case behaves much better. This algorithm works in two steps: first a general context-free parsing algorithm (using the underlying context-free grammar) builds a shared parse forest, and second, the LIG properties are checked on this forest. This check is based upon the composition of simple relations and does not require any computation of symbol stacks.</abstract>
      <bibkey>boullier-1995-yet</bibkey>
    </paper>
    <paper id="8">
      <title>Developing and Evaluating a Probabilistic <fixed-case>LR</fixed-case> Parser of Part-of-Speech and Punctuation Labels</title>
      <author><first>Ted</first><last>Briscoe</last></author>
      <author><first>John</first><last>Carroll</last></author>
      <pages>48-58</pages>
      <url hash="62cfa85d">1995.iwpt-1.8</url>
      <abstract>We describe an approach to robust domain-independent syntactic parsing of unrestricted naturally-occurring (English) input. The technique involves parsing sequences of part-of-speech and punctuation labels using a unification-based grammar coupled with a probabilistic LR parser. We describe the coverage of several corpora using this grammar and report the results of a parsing experiment using probabilities derived from bracketed training data. We report the first substantial experiments to assess the contribution of punctuation to deriving an accurate syntactic analysis, by parsing identical texts both with and without naturally-occurring punctuation marks.</abstract>
      <bibkey>briscoe-carroll-1995-developing</bibkey>
    </paper>
    <paper id="9">
      <title>An Abstract Machine for Attribute-Value Logics</title>
      <author><first>Bob</first><last>Carpenter</last></author>
      <author><first>Yan</first><last>Qu</last></author>
      <pages>59-70</pages>
      <url hash="062549cd">1995.iwpt-1.9</url>
      <abstract>A direct abstract machine implementation of the core attribute-value logic operations is shown to decrease the number of operations and conserve the amount of storage required when compared to interpreters or indirect compilers. In this paper, we describe the fundamental data structures and compilation techniques that we have employed to develop a unification and constraint-resolution engine capable of performance rivaling that of directly compiled Prolog terms while greatly exceeding Prolog in flexibility, expressiveness and modularity. In this paper, we will discuss the core architecture of our machine. We begin with a survey of the data structures supporting the small set of attribute-value logic instructions. These instructions manipulate feature structures by means of features, equality, and typing, and manipulate the program state by search and sequencing operations. We further show how these core operations can be integrated with a broad range of standard parsing techniques. Feature structures improve upon Prolog terms by allowing data to be organized by feature rather than by position. This encourages modular program development through the use of sparse structural descriptions which can be logically conjoined into larger units and directly executed. Standard linguistic representations, even of relatively simple local syntactic and semantic structures, typically run to hundreds of substructures. The type discipline we impose organizes information in an object-oriented manner by the multiple inheritance of classes and their associated features and type value constraints. In practice, this allows the construction of large-scale grammars in a relatively short period of time. At run-time, eager copying and structure-sharing is replaced with lazy, incremental, and localized branch and write operations. In order to allow for applications with parallel search, incremental backtracking can be localized to disjunctive choice points within the description of a single structure, thus supporting the kind of conditional mutual consistency checks used in modern grammatical theories such as HPSG, GB, and LFG. Further attention is paid to the byte-coding of instructions and their efficient indexing and subsequent retrieval, all of which is keyed on type information.</abstract>
      <bibkey>carpenter-qu-1995-abstract</bibkey>
    </paper>
    <paper id="10">
      <title>A Chunking-and-Raising Partial Parser</title>
      <author><first>Hsin-Hsi</first><last>Chen</last></author>
      <author><first>Yue-Shi</first><last>Lee</last></author>
      <pages>71-78</pages>
      <url hash="828e4bad">1995.iwpt-1.10</url>
      <abstract>Parsing is often seen as a combinatorial problem. It is not due to the properties of the natural languages, but due to the parsing strategies. This paper investigates a Constrained Grammar extracted from a Treebank and applies it in a non-combinatorial partial parser. This parser is a simpler version of a chunking-and-raising parser. The chunking and raising actions can be done in linear time. The short-term goal of this research is to help the development of a partially bracketed corpus, i.e., a simpler version of a treebank. The long-term goal is to provide high level linguistic constraints for many natural language applications.</abstract>
      <bibkey>chen-lee-1995-chunking</bibkey>
    </paper>
    <paper id="11">
      <title>Distributed Parsing With <fixed-case>HPSG</fixed-case> Grammars</title>
      <author><first>Abdel Kader</first><last>Diagne</last></author>
      <author><first>Walter</first><last>Kasper</last></author>
      <author><first>Hans-Ulrich</first><last>Krieger</last></author>
      <pages>79-86</pages>
      <url hash="02ce38a9">1995.iwpt-1.11</url>
      <abstract/>
      <bibkey>diagne-etal-1995-distributed</bibkey>
    </paper>
    <paper id="12">
      <title>Chart-based Incremental Semantics Construction with Anaphora Resolution Using <tex-math>\lambda</tex-math>-<fixed-case>DRT</fixed-case></title>
      <author><first>Ingrid</first><last>Fischer</last></author>
      <author><first>Bernd</first><last>Geistert</last></author>
      <author><first>Günther</first><last>Görz</last></author>
      <pages>87-88</pages>
      <url hash="a1948561">1995.iwpt-1.12</url>
      <abstract/>
      <bibkey>fischer-etal-1995-chart</bibkey>
    </paper>
    <paper id="13">
      <title>Term Encoding of Typed Feature Structures</title>
      <author><first>Dale</first><last>Gerdemann</last></author>
      <pages>89-98</pages>
      <url hash="3e9454b2">1995.iwpt-1.13</url>
      <abstract/>
      <bibkey>gerdemann-1995-term</bibkey>
    </paper>
    <paper id="14">
      <title>Generic Rules and Non-Constituent Coordination</title>
      <author><first>Julio</first><last>Gonzalo</last></author>
      <author><first>Teresa</first><last>Solías</last></author>
      <pages>99-110</pages>
      <url hash="969a4280">1995.iwpt-1.14</url>
      <abstract>We present a metagrammatical formalism, <i>generic rules</i>, to give a default interpretation to grammar rules. Our formalism introduces a process of <i>dynamic binding</i> interfacing the level of pure grammatical knowledge representation and the parsing level. We present an approach to non-constituent coordination within categorial grammars, and reformulate it as a generic rule. This reformulation is context-free parsable and reduces drastically the search space associated to the parsing task for such phenomena.</abstract>
      <bibkey>gonzalo-solias-1995-generic</bibkey>
    </paper>
    <paper id="15">
      <title>A Robust Parsing Algorithm for Link Grammars</title>
      <author><first>Dennis</first><last>Grinberg</last></author>
      <author><first>John</first><last>Lafferty</last></author>
      <author><first>Daniel</first><last>Sleator</last></author>
      <pages>111-125</pages>
      <url hash="24a145e3">1995.iwpt-1.15</url>
      <abstract>In this paper we present a robust parsing algorithm based on the link grammar formalism for parsing natural languages. Our algorithm is a natural extension of the original dynamic programming recognition algorithm which recursively counts the number of linkages between two words in the input sentence. The modified algorithm uses the notion of a null link in order to allow a connection between any pair of adjacent words, regardless of their dictionary definitions. The algorithm proceeds by making three dynamic programming passes. In the first pass, the input is parsed using the original algorithm which enforces the constraints on links to ensure grammaticality. In the second pass, the total cost of each substring of words is computed, where cost is determined by the number of null links necessary to parse the substring. The final pass counts the total number of parses with minimal cost. All of the original pruning techniques have natural counterparts in the robust algorithm. When used together with memoization, these techniques enable the algorithm to run efficiently with cubic worst-case complexity. We have implemented these ideas and tested them by parsing the Switchboard corpus of conversational English. This corpus is comprised of approximately three million words of text, corresponding to more than 150 hours of transcribed speech collected from telephone conversations restricted to 70 different topics. Although only a small fraction of the sentences in this corpus are “grammatical” by standard criteria, the robust link grammar parser is able to extract relevant structure for a large portion of the sentences. We present the results of our experiments using this system, including the analyses of selected and random sentences from the corpus. We placed a version of the robust parser on the Word Wide Web for experimentation. It can be reached at URL <url>http://www.cs.cmu.edu/afs/es.emu.edu/project/link/www/robust.html</url>. In this version there are some limitations such as the maximum length of a sentence in words and the maximum amount of memory the parser can use.</abstract>
      <bibkey>grinberg-etal-1995-robust</bibkey>
    </paper>
    <paper id="16">
      <title>An Implementation of Syntactic Analysis of <fixed-case>C</fixed-case>zech</title>
      <author><first>Tomáš</first><last>Holan</last></author>
      <author><first>Vladislav</first><last>Kuboň</last></author>
      <author><first>Martin</first><last>Plátek</last></author>
      <pages>126-135</pages>
      <url hash="1c63a694">1995.iwpt-1.16</url>
      <abstract>This paper describes current results achieved during the work on parsing of a free-word-order natural language (Czech) . It contains theoretical base for a new class of grammars - CFG extended for dependecies and non-projectivities – and also the description of the implementation of a parser and grammar-checker. The paper also describes some typical problems of parsing of free-word-order languages and their solutions (or discusssion of those problems), which are still subject of investigation. The implementation described here serves currently as a testing tool for the development of a large scale grammar of Czech. Some of the quantitative data from a processing of test sentences are also included.</abstract>
      <bibkey>holan-etal-1995-implementation</bibkey>
    </paper>
    <paper id="17">
      <title>Analyzing Coordinate Structures Including Punctuation in <fixed-case>E</fixed-case>nglish</title>
      <author><first>Sadao</first><last>Kurohashi</last></author>
      <pages>136-147</pages>
      <url hash="b3e85ecf">1995.iwpt-1.17</url>
      <abstract>We present a met hod of identifying coordinate structure scopes and determining usages of commas in sentences at the same time. All possible interpretations concerning comma usages and coordinate structure scopes are ranked by taking advantage of parallelism between conjoined phrases/clauses/sentences and calculating their similarity scores. We evaluated this method through experiments on held-out test sentences and obtained promising results: both the success ratio of interpreting commas and that of detecting CS scopes were about 80%.</abstract>
      <bibkey>kurohashi-1995-analyzing</bibkey>
    </paper>
    <paper id="18">
      <title>On Parsing Control for Efficient Text Analysis</title>
      <author><first>Fabio</first><last>Ciravegna</last></author>
      <author><first>Alberto</first><last>Lavelli</last></author>
      <pages>148-149</pages>
      <url hash="fe590662">1995.iwpt-1.18</url>
      <abstract/>
      <bibkey>ciravegna-lavelli-1995-parsing</bibkey>
    </paper>
    <paper id="19">
      <title>A Practical Dependency Parser</title>
      <author><first>Vincenzo</first><last>Lombardo</last></author>
      <author><first>Leonardo</first><last>Lesmo</last></author>
      <pages>150-151</pages>
      <url hash="8ebf73f0">1995.iwpt-1.19</url>
      <abstract>The working assumption is that cognitive modeling of NLP and engineering solutions to free text parsing can converge to optimal parsing. The claim of the paper is that the methodology to achieve such a result is to develop a concrete environment with a flexible parser, that allows the testing of various psycholinguistic strategies on real texts. In this paper we outline a flexible parser based on a dependency grammar.</abstract>
      <bibkey>lombardo-lesmo-1995-practical</bibkey>
    </paper>
    <paper id="20">
      <title>A Labelled Analytic Theorem Proving Environment for Categorial Grammar</title>
      <author><first>Saturnino F.</first><last>Luz-Filho</last></author>
      <author><first>Patrick</first><last>Sturt</last></author>
      <pages>152-161</pages>
      <url hash="e103c029">1995.iwpt-1.20</url>
      <abstract>We present a system for the investigation of computational properties of categorial grammar parsing based on a labelled analytic tableaux theorem prover. This proof method allows us to take a modular approach, in which the basic grammar can be kept constant, while a range of categorial calculi can be captured by assigning different properties to the labelling algebra. The theorem proving strategy is particularly well suited to the treatment of categorial grammar, because it allows us to distribute the computational cost between the algorithm which deals with the grammatical types and the algebraic checker which constrains the derivation.</abstract>
      <bibkey>luz-filho-sturt-1995-labelled</bibkey>
    </paper>
    <paper id="21">
      <title>A Unification-Based <fixed-case>ID</fixed-case>/<fixed-case>LP</fixed-case> Parsing Schema</title>
      <author><first>Frank</first><last>Morawietz</last></author>
      <pages>162-173</pages>
      <url hash="9cb56e58">1995.iwpt-1.21</url>
      <abstract>In contemporary natural language formalisms like HPSG (Pollard and Sag 1994) the ID/LP format is used to separate the information on dominance from the one on linear precedence thereby allowing significant generalizations on word order. In this paper, we define unification ID/LP grammars. But as mentioned in Seiffert (1991) there are problems concerning the locality of the information determining LP acceptability during parsing. Since one is dealing with partially specified data, the information that is relevant to decide whether the local tree under construction is LP acceptable might be instantiated further during processing. In this paper we propose a modification of the Earley/Shieber algorithm on direct parsing of ID/LP grammars. We extend the items involved to include the relevant underspecified information using it in the completion steps to ensure the acceptability of the resulting structure. Following Sikkel (1993) we define it not as an algorithm, but as a parsing schema to allow the most abstract representation.</abstract>
      <bibkey>morawietz-1995-unification</bibkey>
    </paper>
    <paper id="22">
      <title>Parsing Without Grammar</title>
      <author><first>Shinsuke</first><last>Mori</last></author>
      <author><first>Makoto</first><last>Nagao</last></author>
      <pages>174-185</pages>
      <url hash="c3e1f605">1995.iwpt-1.22</url>
      <abstract>We describe and evaluate experimentally a method to parse a tagged corpus without grammar modeling a natural language on context-free language. This method is based on the following three hypotheses. 1) Part-of-speech sequences on the right-hand side of a rewriting rule are less constrained as to what part-of-speech precedes and follows them than non-constituent sequences. 2) Part-of-speech sequences directly derived from the same non-terminal symbol have similar environments. 3) The most suitable set of rewriting rules makes the greatest reduction of the corpus size. Based on these hypotheses, the system finds a set of constituent-like part-of-speech sequences and replaces them with a new symbol. The repetition of these processes brings us a set of rewriting rules, a grammar, and the bracketed corpus.</abstract>
      <bibkey>mori-nagao-1995-parsing</bibkey>
    </paper>
    <paper id="23">
      <title>A Formalism and a Parser for Lexicalised Dependency Grammars</title>
      <author><first>Alexis</first><last>Nasr</last></author>
      <pages>186-195</pages>
      <url hash="56f890e6">1995.iwpt-1.23</url>
      <abstract/>
      <bibkey>nasr-1995-formalism</bibkey>
    </paper>
    <paper id="24">
      <title>Error-tolerant Finite State Recognition</title>
      <author><first>Kemal</first><last>Oflazer</last></author>
      <pages>196-207</pages>
      <url hash="e2b7947f">1995.iwpt-1.24</url>
      <abstract>Error-tolerant recognition enables the recognition of strings that deviate slightly from any string in the regular set recognized by the underlying finite state recognizer. In the context of natural language processing, it has applications in error-tolerant morphological analysis, and spelling correction. After a description of the concepts and algorithms involved, we give examples from these two applications: In morphological analysis, error-tolerant recognition allows misspelled input word forms to be corrected, and morphologically analyzed concurrently. The algorithm can be applied to the moiphological analysis of any language whose morphology is fully captured by a single (and possibly very large) finite state transducer, regardless of the word formation processes (such as agglutination or productive compounding) and morphographemic phenomena involved. We present an application to error tolerant analysis of agglutinative morphology of Turkish words. In spelling correction, error-tolerant recognition can be used to enumerate correct candidate forms from a given misspelled string within a certain edit distance. It can be applied to any language whose morphology is fully described by a finite state transducer, or with a word list comprising all inflected forms with very large word lists of root and inflected forms (some containing well over 200,000 forms), generating all candidate solutions within 10 to 45 milliseconds (with edit distance 1) on a SparcStation 10/41. For spelling correction in Turkish, error-tolerant recognition operating with a (circular) recognizer of Turkish words (with about 29,000 states and 119,000 transitions) can generate all candidate words in less than 20 milliseconds (with edit distance 1). Spelling correction using a recognizer constructed from a large word German list that simulates compounding, also indicates that the approach is applicable in such cases.</abstract>
      <bibkey>oflazer-1995-error</bibkey>
    </paper>
    <paper id="25">
      <title>A Novel Framework for Reductionistic Statistical Parsing</title>
      <author><first>Christer</first><last>Samuelsson</last></author>
      <pages>208-215</pages>
      <url hash="d281fe5c">1995.iwpt-1.25</url>
      <abstract>A reductionistic statistical framework for part-of-speech tagging and surface syntactic parsing is presented that has the same expressive power as the highly successful Constraint Grammar approach, see [Karlsson et al. 1995]. The structure of the Constraint Grammar rules allows them to be viewed as conditional probabilities that can be used to update the lexical tag probabilities, after which low-probability tags are repeatedly removed. Experiments using strictly conventional information sources on the Susanne and Teleman corpora indicate that the system performs as well as a traditional HMM-based part-of-speech tagger, yielding state-of-the-art results. The scheme also enables using the same information sources as the Constraint Grammar approach, and the hope is that it can improve on the performance of both statistical taggers and surface-syntactic analyzers.</abstract>
      <bibkey>samuelsson-1995-novel</bibkey>
    </paper>
    <paper id="26">
      <title>A Corpus-based Probabilistic Grammar with Only Two Non-terminals</title>
      <author><first>Satoshi</first><last>Sekine</last></author>
      <author><first>Ralph</first><last>Grishman</last></author>
      <pages>216-223</pages>
      <url hash="4aa6e318">1995.iwpt-1.26</url>
      <abstract>The availability of large, syntactically-bracketed corpora such as the Penn Tree Bank affords us the opportunity to automatically build or train broad-coverage grammars, and in particular to train probabilistic grammars. A number of recent parsing experiments have also indicated that grammars whose production probabilities are dependent on the context can be more effective than context-free grammars in selecting a correct parse. To make maximal use of context, we have automatically constructed, from the Penn Tree Bank version 2, a grammar in which the symbols S and NP are the only real nonterminals, and the other non-terminals or grammatical nodes are in effect embedded into the right-hand-sides of the S and NP rules. For example, one of the rules extracted from the tree bank would be S -&gt; NP VBX JJ CC VBX NP [1] ( where NP is a non-terminal and the other symbols are terminals – part-of-speech tags of the Tree Bank). The most common structure in the Tree Bank associated with this expansion is (S NP (VP (VP VBX (ADJ JJ) CC (VP VBX NP)))) [2]. So if our parser uses rule [1] in parsing a sentence, it will generate structure [2] for the corresponding part of the sentence. Using 94% of the Penn Tree Bank for training, we extracted 32,296 distinct rules ( 23,386 for S, and 8,910 for NP). We also built a smaller version of the grammar based on higher frequency patterns for use as a back-up when the larger grammar is unable to produce a parse due to memory limitation. We applied this parser to 1,989 Wall Street Journal sentences (separate from the training set and with no limit on sentence length). Of the parsed sentences (1,899), the percentage of no-crossing sentences is 33.9%, and Parseval recall and precision are 73.43% and 72 .61%.</abstract>
      <bibkey>sekine-grishman-1995-corpus</bibkey>
    </paper>
    <paper id="27">
      <title>Heuristics and Parse Ranking</title>
      <author><first>B.</first><last>Srinivas</last></author>
      <author><first>Christine</first><last>Doran</last></author>
      <author><first>Seth</first><last>Kulick</last></author>
      <pages>224-233</pages>
      <url hash="473b0921">1995.iwpt-1.27</url>
      <abstract>There are currently two philosophies for building grammars and parsers – Statistically induced grammars and Wide-coverage grammars. One way to combine the strengths of both approaches is to have a wide-coverage grammar with a heuristic component which is domain independent but whose contribution is tuned to particular domains. In this paper, we discuss a three-stage approach to disambiguation in the context of a lexicalized grammar, using a variety of domain independent heuristic techniques. We present a training algorithm which uses hand-bracketed treebank parses to set the weights of these heuristics. We compare the performance of our grammar against the performance of the IBM statistical grammar, using both untrained and trained weights for the heuristics.</abstract>
      <bibkey>srinivas-etal-1995-heuristics</bibkey>
    </paper>
    <paper id="28">
      <title>Stochastic Parse-Tree Recognition by a Pushdown Automaton</title>
      <author><first>Frédéric</first><last>Tendeau</last></author>
      <pages>234-249</pages>
      <url hash="e8181487">1995.iwpt-1.28</url>
      <abstract>We present the stochastic generalization of what is usually called correctness theorems: we guarantee that the probabilities computed operationally by the parsing algorithms are the same as those defined denotationally on the trees and forests defined by the grammar. The main idea of the paper is to precisely relate the parsing strategy with a parse-tree exploration strategy: a computational path of a parsing. algorithm simply performs an exploration of a parse-tree for the input portion already parsed. This approach is applied in particular to Earley and Left-Corner parsing algorithms. Probability computations follow parsing operations: looping problems (in rule prediction and subtree recognition) are solved by introducing probability variables (which may not be immediately evaluated). Convergence is ensured by the syntactic construction that leads to stochastic equations systems, which are solved as soon as possible. Our algorithms accept any (probabilistic) CF grammar. No restrictions are made such as prescribing normal form, proscribing empty rules or cyclic grammars.</abstract>
      <bibkey>tendeau-1995-stochastic</bibkey>
    </paper>
    <paper id="29">
      <title>An <fixed-case>HPSG</fixed-case>-based Parser for Automatic Knowledge Acquisition</title>
      <author><first>Kentaro</first><last>Torisawa</last></author>
      <author><first>Jun’ichi</first><last>Tsujii</last></author>
      <pages>250-251</pages>
      <url hash="566016d1">1995.iwpt-1.29</url>
      <abstract/>
      <bibkey>torisawa-tsujii-1995-hpsg</bibkey>
    </paper>
    <paper id="30">
      <title>Parsing <fixed-case>D</fixed-case>-Tree Grammars</title>
      <author><first>K.</first><last>Vijay-Shanker</last></author>
      <author><first>David</first><last>Weir</last></author>
      <author><first>Owen</first><last>Rambow</last></author>
      <pages>252-259</pages>
      <url hash="3ef0f98c">1995.iwpt-1.30</url>
      <abstract/>
      <bibkey>vijay-shanker-etal-1995-parsing</bibkey>
    </paper>
    <paper id="31">
      <title>The Influence of Tagging on the Results of Partial Parsing in <fixed-case>G</fixed-case>erman Corpora</title>
      <author><first>Oliver</first><last>Wauschkuhn</last></author>
      <pages>260-270</pages>
      <url hash="b91b2f0c">1995.iwpt-1.31</url>
      <abstract/>
      <bibkey>wauschkuhn-1995-influence</bibkey>
    </paper>
    <paper id="32">
      <title>Partitioning Grammars and Composing Parsers</title>
      <author><first>Fuliang</first><last>Weng</last></author>
      <author><first>Andreas</first><last>Stolcke</last></author>
      <pages>271-272</pages>
      <url hash="537a8354">1995.iwpt-1.32</url>
      <abstract/>
      <bibkey>weng-stolcke-1995-partitioning</bibkey>
    </paper>
    <paper id="33">
      <title>Parsing with Typed Feature Structures</title>
      <author><first>Shuly</first><last>Wintner</last></author>
      <author><first>Nissim</first><last>Francez</last></author>
      <pages>273-287</pages>
      <url hash="9124f7dc">1995.iwpt-1.33</url>
      <abstract>In this paper we provide for parsing with respect to grammars expressed in a general TFS-based formalism, a restriction of ALE ([2]). Our motivation being the design of an abstract (WAM-like) machine for the formalism ([14]), we consider parsing as a computational process and use it as an operational semantics to guide the design of the control structures for the abstract machine. We emphasize the notion of <i>abstract typed feature structures</i> (AFSs) that encode the essential information of TFSs and define unification over AFSs rather than over TFSs. We then introduce an explicit construct of <i>multi-rooted feature structures</i> (MRSs) that naturally extend TFSs and use them to represent phrasal signs as well as grammar rules. We also employ abstractions of MRSs and give the mathematical foundations needed for manipulating them. We then present a simple bottom-up chart parser as a model for computation: grammars written in the TFS-based formalism are executed by the parser. Finally, we show that the parser is correct.</abstract>
      <bibkey>wintner-francez-1995-parsing</bibkey>
    </paper>
  </volume>
</collection>
